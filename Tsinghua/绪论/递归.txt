递归则是函数和过程调用的一种特殊形式，即允许函数和过程进行自我调用
递归也可能以间接的形式出现，即某个方法首先调用其它方法，再辗转通过其它方法的相互调用，最终调用起始的方法自身。

线性递归
		保证递归算法有穷性的基本技巧： 首先判断并处理n = 0之类的平凡情况，以免因无限递归而导致系统溢出。这类平凡情况统称“递归基”（base case of recursion）。
	平凡情况可能有多种，但至少要有一种（比如此处） ，且迟早必然会出现。
		每一层次上至多只有一个实例，且它们构成一个线性的次序关系。此类递归模式因而称作“线性递归” （linear recursion） ，它也是递归的最基本形式。
		线性递归的模式， 往往对应于所谓减而治之（decrease-and-conquer） 的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。

递归分析
	递归跟踪:作为一种直观且可视的方法，递归跟踪（recursion trace） 可用以分析递归算法的总体运行时间与空间。
	只需统计各递归实例中非递归调用部分所需的时间。
	递推方程：与递归跟踪分析相反， 该方法无需绘出具体的调用过程，而是通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析， 转化为递归方程（组）的求解。

递归模式
	多递归基:为保证有穷性，递归算法都必须设置递归基，且确保总能执行到。 为此， 针对每一类可能出现的平凡情况，都需设置对应的递归基， 故同一算法的递归基可能（显式或隐式地）不止一个。
	多向递归:递归算法中，不仅递归基可能有多个，递归调用也可能有多种可供选择的分支
	
递归消除
	尾递归及其消除
	在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递归（tail recursion） 。
二分递归:
	分而治之 将其分解为若干规模更小的子问题， 再通过递归机制分别求解。 这种分解持续进行，直到子问题规模缩减至平凡情况。这也就是所谓的分而治之（divide-and-conquer） 策略。
	并非所有问题都适宜于采用分治策略。实际上除了递归，此类算法的计算消耗主要来自两个方面。首先是子问题划分，即把原问题分解为形式相同、规模更小的多个子问题
	其次是子解答合并，即由递归所得子问题的解，得到原问题的整体解，比如由子数组之和累加得到整个数组之和。
	为使分治策略真正有效， 不仅必须保证以上两方面的计算都能高效地实现， 还必须保证子问题之间相互独立各子问题可独立求解， 而无需借助其它子问题的原始数据或中间结果。
	
	优化策略
		为消除递归算法中重复的递归实例， 一种自然而然的思路和技巧，可以概括为：借助一定量的辅助空间， 在各子问题求解之后，及时记录下其对应的解答
		可以从原问题出发自顶而下，每当遇到一个子问题，都首先查验它是否已经计算过，以期通过直接调阅记录获得解答，从而避免重新计算。 也可以从递归基出发，自底而上递推地得
		出各子问题的解，直至最终原问题的解。前者即所谓的制表（tabulation）或记忆（memoization）策略，后者即所谓的动态规划（dynamic programming） 策略。